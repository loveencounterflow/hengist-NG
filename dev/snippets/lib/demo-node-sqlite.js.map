{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/demo-node-sqlite.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n#===========================================================================================================\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'demo-node-sqlite'\n{ rpr\n  inspect\n  echo\n  white\n  green\n  blue\n  gold\n  grey\n  red\n  bold\n  reverse\n  log     }               = GUY.trm\n{ f }                     = require '../../../apps/effstring'\n# write                     = ( p ) -> process.stdout.write p\n{ nfa }                   = require '../../../apps/normalize-function-arguments'\nGTNG                      = require '../../../apps/guy-test-NG'\n{ Test                  } = GTNG\nSFMODULES                 = require '../../../apps/bricabrac-single-file-modules'\nmkdirp                    = require 'mkdirp'\nenv_paths                 = ( require 'env-paths' ).default 'demo-node-sqlite'\nSQLITE                    = require 'node:sqlite'\nPATH                      = require 'node:path'\n{ SQL }                   = require '../../../apps/dbay'\n\n\n#===========================================================================================================\nillegal_codepoint_patterns =\n  unassigned: ///^\\p{Cn}$///v # Control\n  control:    ///^\\p{C}$///v # Control\n  letter:     ///^\\p{L}$///v\n  space:      ///^\\p{Zs}$///v\n  separator:  ///^\\p{Z}$///v\n  mark:       ///^\\p{M}$///v\n  # surrogate:  ///^\\p{C}$///v # Surrogate\n\nget_rough_unicode_category = ( chr ) ->\n  for name, pattern of illegal_codepoint_patterns\n    return name if pattern.test chr\n  return 'other'\n\n#===========================================================================================================\nclass Node_sqlite\n\n  #---------------------------------------------------------------------------------------------------------\n  @functions: {}\n  @statements: {}\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( db_path ) ->\n    @db                 = new SQLITE.DatabaseSync db_path\n    clasz               = @constructor\n    ### NOTE we can't just prepare all the stetments as they depend on DB objects existing or not existing,\n    as the case may be. Hence we prepare statements on-demand and cache them here as needed: ###\n    @statements         = {}\n    #.......................................................................................................\n    ### TAINT move to proper attribute of proper class ###\n    #.......................................................................................................\n    call = ( text ) ->\n      debug 'Ωnql___1', @cache\n      ### TAINT preliminary implementation ###\n      return ( Array.from text ).length\n    call = call.bind @\n    @db.function 'width_from_text', { deterministic: true, varargs: false, }, call\n    #.......................................................................................................\n    call = ( text ) ->\n      return ( Array.from text ).length\n    call = call.bind @\n    @db.function 'length_from_text', { deterministic: true, varargs: false, }, call\n    #.......................................................................................................\n    for name, sql of clasz.statements\n      switch true\n        when name.startsWith 'create_table_'\n          null\n        when name.startsWith 'insert_'\n          null\n        else\n          throw new Error \"Ωnql___2 unable to parse statement name #{rpr name}\"\n    #   @[ name ] = @prepare sql\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  execute: ( sql ) -> @db.exec sql\n\n  #---------------------------------------------------------------------------------------------------------\n  prepare: ( sql ) -> @db.prepare sql\n\n\n#===========================================================================================================\nclass Segment_width_db extends Node_sqlite\n\n  #---------------------------------------------------------------------------------------------------------\n  @functions:\n    width_from_text:\n      deterministic:  true\n      varargs:        false\n      call:           ( text ) ->\n        debug 'Ωnql___3', @cache\n        ### TAINT preliminary implementation ###\n        return ( Array.from text ).length\n    length_from_text:\n      deterministic:  true\n      varargs:        false\n      call:           ( text ) -> ( Array.from text ).length\n\n  #---------------------------------------------------------------------------------------------------------\n  @statements:\n    #.......................................................................................................\n    create_table_segments: SQL\"\"\"\n      drop table if exists segments;\n      create table segments (\n          segment_text      text    not null primary key,\n          segment_width     integer not null generated always as ( width_from_text(  segment_text ) ) stored,\n          segment_length    integer not null generated always as ( length_from_text( segment_text ) ) stored,\n        constraint segment_width_eqgt_zero  check ( segment_width  >= 0 ),\n        constraint segment_length_eqgt_zero check ( segment_length >= 0 ) );\"\"\"\n    # #.......................................................................................................\n    # insert_segment: SQL\"\"\"\n    #   insert into segments  ( segment_text,   segment_width,  segment_length  )\n    #                 values  ( $segment_text,  $segment_width, $segment_length )\n    #     on conflict ( segment_text ) do update\n    #                 set     (                 segment_width,  segment_length  ) =\n    #                         ( excluded.segment_width, excluded.segment_length );\"\"\"\n    #.......................................................................................................\n    insert_segment: SQL\"\"\"\n      insert into segments  ( segment_text  )\n                    values  ( $segment_text )\n        on conflict ( segment_text ) do nothing;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( db_path ) ->\n    super db_path\n    @cache = new Map()\n    return undefined\n\n#===========================================================================================================\ndemo = =>\n  debug 'Ωnql___4', k, v for k, v of env_paths\n  tmp_path  = env_paths.temp\n  db_path   = PATH.join tmp_path, 'chr-widths.sqlite'\n  debug 'Ωnql___5', mkdirp.sync tmp_path\n  debug 'Ωnql___6', db = new Segment_width_db db_path\n  #.........................................................................................................\n  db.execute SQL\"\"\"drop table if exists segments;\"\"\"\n  db.execute db.constructor.statements.create_table_segments\n  insert_segment = db.prepare db.constructor.statements.insert_segment\n  #.........................................................................................................\n  all_segments = db.prepare SQL\"\"\"select * from segments order by segment_text;\"\"\"\n  #.........................................................................................................\n  db.execute SQL\"\"\"begin transaction;\"\"\"\n  for cid in [ 0x00_000c .. 0x00_0050 ]\n    chr     = String.fromCodePoint cid\n    cid_hex = \"U+#{( cid.toString 16 ).padStart 4, '0'}\"\n    chr     = String.fromCodePoint cid\n    ucc     = get_rough_unicode_category chr\n    # debug 'Ωbbsfm___7', cid_hex, ( rpr chr ), ucc\n    segment_text    = chr\n    segment_width   = null\n    segment_length  = null\n    switch ucc\n      when 'control'\n        segment_width   = 0\n        segment_length  = 0\n      when 'separator'\n        segment_width   = 0\n        segment_length  = 0\n      else\n        segment_width   = 1 ### TAINT run wc --max-line-length ###\n        segment_length  = 1\n    insert_segment.run { segment_text, }\n  insert_segment.run { segment_text: \"a somewhat longer text\", }\n  db.execute SQL\"\"\"commit;\"\"\"\n  for { segment_text, segment_width, segment_length, } from all_segments.iterate()\n    info 'Ωnql___8', ( rpr segment_text ), segment_width, segment_length\n  #.........................................................................................................\n  # some_segments = db.prepare SQL\"\"\"select * from segments where segment_text in ( $texts );\"\"\"\n  # debug 'Ωnql___9', some_segments.run { texts: [ 'a', 'b', ], }\n  some_segments = db.prepare SQL\"\"\"select * from segments where segment_text in (\n    select value from json_each(?) );\"\"\"\n  # some_segments.setReturnArrays true\n  for { segment_text, segment_width, segment_length, }, idx in some_segments.all ( JSON.stringify [ 'a', 'b', ] )\n    urge 'Ωnql__10', idx, ( rpr segment_text ), segment_width, segment_length\n  #.........................................................................................................\n  some_segments_with_widths = db.prepare SQL\"\"\"\n    select\n      $text as my_text,\n      width_from_text( $text ) as width;\"\"\"\n  debug 'Ωnql__11', some_segments_with_widths.all { text: '765', }\n  #.........................................................................................................\n  return null\n\n#===========================================================================================================\nif module is require.main then await do =>\n  await demo()\n  return null\n"
  ]
}