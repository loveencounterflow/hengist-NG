{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/demo-node-sqlite.coffee"
  ],
  "names": [],
  "mappings": "AACA;EAAA;AAAA,MAAA,IAAA,EAAA,GAAA,EAAA,WAAA,EAAA,IAAA,EAAA,SAAA,EAAA,GAAA,EAAA,MAAA,EAAA,gBAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,SAAA,EAAA,CAAA,EAAA,0BAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,0BAAA,EAAA,IAAA,EAAA,OAAA,EAAA,GAAA,EAAA,MAAA,EAAA,GAAA,EAAA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAAA,KAAA;;;EAGA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,CAAA,CAAE,KAAF,EACE,KADF,EAEE,IAFF,EAGE,IAHF,EAIE,KAJF,EAKE,MALF,EAME,IANF,EAOE,IAPF,EAQE,OARF,CAAA,GAQ4B,GAAG,CAAC,GAAG,CAAC,WAAR,CAAoB,kBAApB,CAR5B;;EASA,CAAA,CAAE,GAAF,EACE,OADF,EAEE,IAFF,EAGE,KAHF,EAIE,KAJF,EAKE,IALF,EAME,IANF,EAOE,IAPF,EAQE,GARF,EASE,IATF,EAUE,OAVF,EAWE,GAXF,CAAA,GAW4B,GAAG,CAAC,GAXhC;;EAYA,CAAA,CAAE,CAAF,CAAA,GAA4B,OAAA,CAAQ,yBAAR,CAA5B,EAzBA;;;EA2BA,CAAA,CAAE,GAAF,CAAA,GAA4B,OAAA,CAAQ,4CAAR,CAA5B;;EACA,IAAA,GAA4B,OAAA,CAAQ,2BAAR;;EAC5B,CAAA,CAAE,IAAF,CAAA,GAA4B,IAA5B;;EACA,SAAA,GAA4B,OAAA,CAAQ,6CAAR;;EAC5B,MAAA,GAA4B,OAAA,CAAQ,QAAR;;EAC5B,SAAA,GAA4B,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,OAAxB,CAAgC,kBAAhC;;EAC5B,MAAA,GAA4B,OAAA,CAAQ,aAAR;;EAC5B,IAAA,GAA4B,OAAA,CAAQ,WAAR;;EAC5B,CAAA,CAAE,GAAF,CAAA,GAA4B,OAAA,CAAQ,oBAAR,CAA5B,EAnCA;;;EAuCA,0BAAA,GACE;IAAA,UAAA,EAAY,WAAZ;IACA,OAAA,EAAY,UADZ;IAEA,MAAA,EAAY,UAFZ;IAGA,KAAA,EAAY,WAHZ;IAIA,SAAA,EAAY,UAJZ;IAKA,IAAA,EAAY;EALZ,EAxCF;;;EAgDA,0BAAA,GAA6B,QAAA,CAAE,GAAF,CAAA;AAC7B,QAAA,IAAA,EAAA;IAAE,KAAA,kCAAA;;MACE,IAAe,OAAO,CAAC,IAAR,CAAa,GAAb,CAAf;AAAA,eAAO,KAAP;;IADF;AAEA,WAAO;EAHoB;;EAMvB;;IAAN,MAAA,YAAA,CAAA;;MAOE,WAAa,CAAE,OAAF,CAAA;AACf,YAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,eAAA,EAAA,IAAA,EAAA;QAAI,IAAC,CAAA,EAAD,GAAsB,IAAI,MAAM,CAAC,YAAX,CAAwB,OAAxB;QACtB,KAAA,GAAsB,IAAC,CAAA,YAD3B;;;QAII,IAAC,CAAA,UAAD,GAAsB,CAAA,EAJ1B;;QAMI,eAAA,GAAkB;UAAE,aAAA,EAAe,IAAjB;UAAuB,OAAA,EAAS;QAAhC;AAClB;QAAA,KAAA,WAAA;;UACE,IAAG,CAAE,OAAO,MAAT,CAAA,KAAqB,UAAxB;YACE,CAAE,IAAF,EAAQ,MAAR,CAAA,GAAoB,CAAE,MAAF,EAAU,CAAA,CAAV,EADtB;WAAA,MAAA;YAGE,CAAA,CAAE,IAAF,CAAA,GAAY,MAAZ,EAHF;;UAIA,MAAA,GAAU,CAAE,GAAA,eAAF,EAAsB,MAAtB;UACV,IAAA,GAAU,IAAI,CAAC,IAAL,CAAU,IAAV;UACV,IAAC,CAAA,EAAE,CAAC,QAAJ,CAAa,IAAb,EAAmB,MAAnB,EAA2B,IAA3B;QAPF,CAPJ;;;;;;;;;;;AAyBI,eAAO;MA1BI,CALf;;;MAkCE,OAAS,CAAE,GAAF,CAAA;eAAW,IAAC,CAAA,EAAE,CAAC,IAAJ,CAAS,GAAT;MAAX,CAlCX;;;MAqCE,OAAS,CAAE,GAAF,CAAA;eAAW,IAAC,CAAA,EAAE,CAAC,OAAJ,CAAY,GAAZ;MAAX;;IAvCX;;;IAGE,WAAC,CAAA,SAAD,GAAY,CAAA;;IACZ,WAAC,CAAA,UAAD,GAAa,CAAA;;;;;;EAuCT;;IAAN,MAAA,iBAAA,QAA+B,YAA/B,CAAA;;MA6CE,WAAa,CAAE,OAAF,CAAA;AACf,YAAA;aAAI,CAAM,OAAN;QACA,KAAA,GAAU,IAAC,CAAA;QACX,IAAC,CAAA,KAAD,GAAU,IAAI,GAAJ,CAAA,EAFd;;QAII,IAAC,CAAA,UAAD,GACE;UAAA,cAAA,EAA0B,IAAC,CAAA,OAAD,CAAS,KAAK,CAAC,UAAU,CAAC,cAA1B,CAA1B;UACA,wBAAA,EAA0B,IAAC,CAAA,OAAD,CAAS,KAAK,CAAC,UAAU,CAAC,wBAA1B;QAD1B;AAEF,eAAO;MARI,CA3Cf;;;MAsDE,mBAAqB,CAAA,GAAE,aAAF,CAAA;AACvB,YAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA;QACI,aAAA,GAAgB,aAAa,CAAC,IAAd,CAAmB,KAAnB;QAChB,CAAA,GAAI,MAAM,CAAC,MAAP,CAAc,IAAd;QACJ,KAAA,+CAAA;;UACE,IAAG,4CAAH;YACE,KADF;WAAA,MAEK,IAAG,4EAAH;YACH,IAAC,CAAA,KAAK,CAAC,GAAP,CAAW,YAAX,EAAyB,GAAzB,EADG;WAAA,MAAA;YAGH,GAAA,GAAM,IAAC,CAAA,UAAU,CAAC,cAAc,CAAC,GAA3B,CAA+B,CAAE,YAAF,CAA/B;YACN,IAAC,CAAA,KAAK,CAAC,GAAP,CAAW,YAAX,EAAyB,GAAzB,EAJG;;UAKL,CAAC,CAAE,YAAF,CAAD,GAAoB;QARtB;AASA,eAAO;MAbY,CAtDvB;;;MAsEE,0BAA4B,CAAE,YAAF,CAAA;AAAmB,YAAA,CAAA,EAAA,CAAA,EAAA;AAAC;QAAA,KAAA,QAAA;;AAAA,iBAAO;QAAP;MAApB;;IAxE9B;;;IAGE,gBAAC,CAAA,SAAD,GACE;MAAA,eAAA,EACE;QAAA,aAAA,EAAgB,IAAhB;QACA,OAAA,EAAgB,KADhB;QAEA,IAAA,EAAgB,QAAA,CAAE,IAAF,CAAA,EAAA;;;AAGd,iBAAO,CAAE,KAAK,CAAC,IAAN,CAAW,IAAX,CAAF,CAAmB,CAAC;QAHb;MAFhB,CADF;MAOA,gBAAA,EACE;QAAA,aAAA,EAAgB,IAAhB;QACA,OAAA,EAAgB,KADhB;QAEA,IAAA,EAAgB,QAAA,CAAE,IAAF,CAAA;iBAAY,CAAE,KAAK,CAAC,IAAN,CAAW,IAAX,CAAF,CAAmB,CAAC;QAAhC;MAFhB;IARF;;;IAaF,gBAAC,CAAA,UAAD,GAEE,CAAA;;MAAA,qBAAA,EAAuB,GAAG,CAAA;;;;;;sEAAA,CAA1B;;;;;;;;;MAgBA,cAAA,EAAgB,GAAG,CAAA;;;cAAA,CAhBnB;;MAsBA,wBAAA,EAA0B,GAAG,CAAA,kEAAA;IAtB7B;;;;gBApHJ;;;EA6KA,IAAA,GAAO,CAAA,CAAA,GAAA;AACP,QAAA,YAAA,EAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,cAAA,EAAA,EAAA,EAAA,OAAA,EAAA,CAAA,EAAA,cAAA,EAAA,CAAA,EAAA,cAAA,EAAA,YAAA,EAAA,aAAA,EAAA,QAAA,EAAA,GAAA,EAAA;IAAE,KAAA,cAAA;;MAAA,KAAA,CAAM,UAAN,EAAkB,CAAlB,EAAqB,CAArB;IAAA;IACA,QAAA,GAAY,SAAS,CAAC;IACtB,OAAA,GAAY,IAAI,CAAC,IAAL,CAAU,QAAV,EAAoB,mBAApB;IACZ,KAAA,CAAM,UAAN,EAAkB,MAAM,CAAC,IAAP,CAAY,QAAZ,CAAlB;IACA,KAAA,CAAM,UAAN,EAAkB,EAAA,GAAK,IAAI,gBAAJ,CAAqB,OAArB,CAAvB,EAJF;;IAME,EAAE,CAAC,OAAH,CAAW,GAAG,CAAA,8BAAA,CAAd;IACA,EAAE,CAAC,OAAH,CAAW,EAAE,CAAC,WAAW,CAAC,UAAU,CAAC,qBAArC;IACA,cAAA,GAAiB,EAAE,CAAC,OAAH,CAAW,EAAE,CAAC,WAAW,CAAC,UAAU,CAAC,cAArC,EARnB;;IAUE,YAAA,GAAe,EAAE,CAAC,OAAH,CAAW,GAAG,CAAA,6CAAA,CAAd,EAVjB;;IAYE,EAAE,CAAC,OAAH,CAAW,GAAG,CAAA,kBAAA,CAAd;IACA,KAAW,uCAAX;MACE,GAAA,GAAU,MAAM,CAAC,aAAP,CAAqB,GAArB;MACV,OAAA,GAAU,CAAA,EAAA,CAAA,CAAK,CAAE,GAAG,CAAC,QAAJ,CAAa,EAAb,CAAF,CAAmB,CAAC,QAApB,CAA6B,CAA7B,EAAgC,GAAhC,CAAL,CAAA;MACV,GAAA,GAAU,MAAM,CAAC,aAAP,CAAqB,GAArB;MACV,GAAA,GAAU,0BAAA,CAA2B,GAA3B,EAHd;;MAKI,YAAA,GAAkB;MAClB,aAAA,GAAkB;MAClB,cAAA,GAAkB;AAClB,cAAO,GAAP;AAAA,aACO,SADP;UAEI,aAAA,GAAkB;UAClB,cAAA,GAAkB;AAFf;AADP,aAIO,WAJP;UAKI,aAAA,GAAkB;UAClB,cAAA,GAAkB;AAFf;AAJP;UAQI,aAAA,GAAkB,CAAE;UACpB,cAAA,GAAkB;AATtB;MAUA,IAAA,CAAK,UAAL,EAAiB,cAAc,CAAC,GAAf,CAAmB,CAAE,YAAF,CAAnB,CAAjB;IAnBF;IAoBA,EAAE,CAAC,OAAH,CAAW,GAAG,CAAA,OAAA,CAAd;IACA,IAAA,CAAK,UAAL,EAAiB,cAAc,CAAC,GAAf,CAAmB;MAAE,YAAA,EAAc;IAAhB,CAAnB,CAAjB;IACA,IAAA,CAAK,UAAL,EAAiB,cAAc,CAAC,GAAf,CAAmB;MAAE,YAAA,EAAc;IAAhB,CAAnB,CAAjB;IACA,IAAA,CAAK,UAAL,EAAiB,cAAc,CAAC,GAAf,CAAmB;MAAE,YAAA,EAAc;IAAhB,CAAnB,CAAjB;IACA,IAAA,CAAK,UAAL,EAAiB,cAAc,CAAC,GAAf,CAAmB;MAAE,YAAA,EAAc;IAAhB,CAAnB,CAAjB;IACA,cAAA,GAAiB,EAAE,CAAC,OAAH,CAAW,GAAG,CAAA,8BAAA,CAAd;IACjB,IAAA,CAAK,UAAL,EAAiB,cAAc,CAAC,GAAf,CAAA,CAAjB,EAvCF;;;;;;;;;;;;IAmDE,IAAA,CAAK,UAAL,EAAiB,EAAE,CAAC,KAAK,CAAC,IAA1B;IACA,IAAA,CAAK,UAAL,EAAiB,EAAE,CAAC,mBAAH,CAAuB,GAAvB,EAA4B,wBAA5B,EAAsD,GAAtD,CAAjB;IACA,IAAA,CAAK,UAAL,EAAiB,EAAE,CAAC,KAAK,CAAC,IAA1B;IACA,IAAA,CAAK,UAAL,EAAiB,EAAE,CAAC,0BAAH,CAA8B,YAA9B,CAAjB;IACA,IAAA,CAAK,UAAL,EAAiB,EAAE,CAAC,KAAK,CAAC,IAA1B,EAvDF;;;;;;;;;AAgEE,WAAO;EAjEF,EA7KP;;;EAiPA,IAAG,MAAA,KAAU,OAAO,CAAC,IAArB;IAA+B,MAAS,CAAA,KAAA,CAAA,CAAA,GAAA;MACtC,MAAM,IAAA,CAAA;AACN,aAAO;IAF+B,CAAA,IAAxC;;AAjPA",
  "sourcesContent": [
    "\n'use strict'\n\n#===========================================================================================================\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'demo-node-sqlite'\n{ rpr\n  inspect\n  echo\n  white\n  green\n  blue\n  gold\n  grey\n  red\n  bold\n  reverse\n  log     }               = GUY.trm\n{ f }                     = require '../../../apps/effstring'\n# write                     = ( p ) -> process.stdout.write p\n{ nfa }                   = require '../../../apps/normalize-function-arguments'\nGTNG                      = require '../../../apps/guy-test-NG'\n{ Test                  } = GTNG\nSFMODULES                 = require '../../../apps/bricabrac-single-file-modules'\nmkdirp                    = require 'mkdirp'\nenv_paths                 = ( require 'env-paths' ).default 'demo-node-sqlite'\nSQLITE                    = require 'node:sqlite'\nPATH                      = require 'node:path'\n{ SQL }                   = require '../../../apps/dbay'\n\n\n#===========================================================================================================\nillegal_codepoint_patterns =\n  unassigned: ///^\\p{Cn}$///v # Control\n  control:    ///^\\p{C}$///v # Control\n  letter:     ///^\\p{L}$///v\n  space:      ///^\\p{Zs}$///v\n  separator:  ///^\\p{Z}$///v\n  mark:       ///^\\p{M}$///v\n  # surrogate:  ///^\\p{C}$///v # Surrogate\n\nget_rough_unicode_category = ( chr ) ->\n  for name, pattern of illegal_codepoint_patterns\n    return name if pattern.test chr\n  return 'other'\n\n#===========================================================================================================\nclass Node_sqlite\n\n  #---------------------------------------------------------------------------------------------------------\n  @functions: {}\n  @statements: {}\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( db_path ) ->\n    @db                 = new SQLITE.DatabaseSync db_path\n    clasz               = @constructor\n    ### NOTE we can't just prepare all the stetments as they depend on DB objects existing or not existing,\n    as the case may be. Hence we prepare statements on-demand and cache them here as needed: ###\n    @statements         = {}\n    #.......................................................................................................\n    fn_cfg_template = { deterministic: true, varargs: false, }\n    for name, fn_cfg of clasz.functions\n      if ( typeof fn_cfg ) is 'function'\n        [ call, fn_cfg, ] = [ fn_cfg, {}, ]\n      else\n        { call, } = fn_cfg\n      fn_cfg  = { fn_cfg_template..., fn_cfg, }\n      call    = call.bind @\n      @db.function name, fn_cfg, call\n    # #.......................................................................................................\n    # for name, sql of clasz.statements\n    #   switch true\n    #     when name.startsWith 'create_table_'\n    #       null\n    #     when name.startsWith 'insert_'\n    #       null\n    #     else\n    #       throw new Error \"Î©nql___1 unable to parse statement name #{rpr name}\"\n    # #   @[ name ] = @prepare sql\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  execute: ( sql ) -> @db.exec sql\n\n  #---------------------------------------------------------------------------------------------------------\n  prepare: ( sql ) -> @db.prepare sql\n\n\n#===========================================================================================================\nclass Segment_width_db extends Node_sqlite\n\n  #---------------------------------------------------------------------------------------------------------\n  @functions:\n    width_from_text:\n      deterministic:  true\n      varargs:        false\n      call:           ( text ) ->\n        # debug 'Î©nql___2', 'width_from_text', @cache\n        ### TAINT preliminary implementation ###\n        return ( Array.from text ).length\n    length_from_text:\n      deterministic:  true\n      varargs:        false\n      call:           ( text ) -> ( Array.from text ).length\n\n  #---------------------------------------------------------------------------------------------------------\n  @statements:\n    #.......................................................................................................\n    create_table_segments: SQL\"\"\"\n      drop table if exists segments;\n      create table segments (\n          segment_text      text    not null primary key,\n          segment_width     integer not null generated always as ( width_from_text(  segment_text ) ) stored,\n          segment_length    integer not null generated always as ( length_from_text( segment_text ) ) stored,\n        constraint segment_width_eqgt_zero  check ( segment_width  >= 0 ),\n        constraint segment_length_eqgt_zero check ( segment_length >= 0 ) );\"\"\"\n    # #.......................................................................................................\n    # insert_segment: SQL\"\"\"\n    #   insert into segments  ( segment_text,   segment_width,  segment_length  )\n    #                 values  ( $segment_text,  $segment_width, $segment_length )\n    #     on conflict ( segment_text ) do update\n    #                 set     (                 segment_width,  segment_length  ) =\n    #                         ( excluded.segment_width, excluded.segment_length );\"\"\"\n    #.......................................................................................................\n    insert_segment: SQL\"\"\"\n      insert into segments  ( segment_text  )\n                    values  ( $segment_text )\n        on conflict ( segment_text ) do nothing\n        returning *;\"\"\"\n    #.......................................................................................................\n    select_row_from_segments: SQL\"\"\"\n      select * from segments where segment_text = $segment_text limit 1;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( db_path ) ->\n    super db_path\n    clasz   = @constructor\n    @cache  = new Map()\n    ### TAINT should be done automatically ###\n    @statements =\n      insert_segment:           @prepare clasz.statements.insert_segment\n      select_row_from_segments: @prepare clasz.statements.select_row_from_segments\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  get_segment_metrics: ( segment_texts... ) ->\n    ### TAINT consider bundling requests into single one using JSON array ###\n    segment_texts = segment_texts.flat Infinity\n    R = Object.create null\n    for segment_text in segment_texts\n      if ( row = @cache.get segment_text )?\n        null\n      else if ( row = @statements.select_row_from_segments.get { segment_text, } )?\n        @cache.set segment_text, row\n      else\n        row = @statements.insert_segment.get { segment_text, }\n        @cache.set segment_text, row\n      R[ segment_text ] = row\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  get_single_segment_metrics: ( segment_text ) -> return R for _, R of @get_segment_metrics segment_text\n\n\n#===========================================================================================================\ndemo = =>\n  debug 'Î©nql___3', k, v for k, v of env_paths\n  tmp_path  = env_paths.temp\n  db_path   = PATH.join tmp_path, 'chr-widths.sqlite'\n  debug 'Î©nql___4', mkdirp.sync tmp_path\n  debug 'Î©nql___5', db = new Segment_width_db db_path\n  #.........................................................................................................\n  db.execute SQL\"\"\"drop table if exists segments;\"\"\"\n  db.execute db.constructor.statements.create_table_segments\n  insert_segment = db.prepare db.constructor.statements.insert_segment\n  #.........................................................................................................\n  all_segments = db.prepare SQL\"\"\"select * from segments order by segment_text;\"\"\"\n  #.........................................................................................................\n  db.execute SQL\"\"\"begin transaction;\"\"\"\n  for cid in [ 0x00_000c .. 0x00_0050 ]\n    chr     = String.fromCodePoint cid\n    cid_hex = \"U+#{( cid.toString 16 ).padStart 4, '0'}\"\n    chr     = String.fromCodePoint cid\n    ucc     = get_rough_unicode_category chr\n    # debug 'Î©bbsfm___6', cid_hex, ( rpr chr ), ucc\n    segment_text    = chr\n    segment_width   = null\n    segment_length  = null\n    switch ucc\n      when 'control'\n        segment_width   = 0\n        segment_length  = 0\n      when 'separator'\n        segment_width   = 0\n        segment_length  = 0\n      else\n        segment_width   = 1 ### TAINT run wc --max-line-length ###\n        segment_length  = 1\n    info 'Î©nql___7', insert_segment.all { segment_text, }\n  db.execute SQL\"\"\"commit;\"\"\"\n  info 'Î©nql___8', insert_segment.all { segment_text: \"a somewhat longer text\", }\n  info 'Î©nql___9', insert_segment.all { segment_text: \"a text\", }\n  info 'Î©nql__10', insert_segment.all { segment_text: \"A\", }\n  info 'Î©nql__11', insert_segment.all { segment_text: \"9\", }\n  count_segments = db.prepare SQL\"select count(*) from segments;\"\n  info 'Î©nql__12', count_segments.all()\n  # for { segment_text, segment_width, segment_length, } from all_segments.iterate()\n  #   info 'Î©nql__13', ( rpr segment_text ), segment_width, segment_length\n  #.........................................................................................................\n  # some_segments = db.prepare SQL\"\"\"select * from segments where segment_text in ( $texts );\"\"\"\n  # debug 'Î©nql__14', some_segments.run { texts: [ 'a', 'b', ], }\n  # some_segments = db.prepare SQL\"\"\"select * from segments where segment_text in (\n  #   select value from json_each(?) );\"\"\"\n  # some_segments.setReturnArrays true\n  # for { segment_text, segment_width, segment_length, }, idx in some_segments.all ( JSON.stringify [ 'a', 'b', ] )\n  #   urge 'Î©nql__15', idx, ( rpr segment_text ), segment_width, segment_length\n  #.........................................................................................................\n  info 'Î©nql__16', db.cache.size\n  info 'Î©nql__17', db.get_segment_metrics 'A', 'a somewhat longer text', 'Z'\n  info 'Î©nql__18', db.cache.size\n  info 'Î©nql__19', db.get_single_segment_metrics 'a new text'\n  info 'Î©nql__20', db.cache.size\n  # info 'Î©nql__21', db.cache\n  # #.........................................................................................................\n  # some_segments_with_widths = db.prepare SQL\"\"\"\n  #   select\n  #     $text as my_text,\n  #     width_from_text( $text ) as width;\"\"\"\n  # debug 'Î©nql__22', some_segments_with_widths.all { text: '765', }\n  #.........................................................................................................\n  return null\n\n#===========================================================================================================\nif module is require.main then await do =>\n  await demo()\n  return null\n"
  ]
}