{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/demo-fstrings-ported.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'intertype/test-basics'\n{ rpr\n  inspect\n  echo\n  reverse\n  log     }               = GUY.trm\n\n\n\n############################################################################################################\n############################################################################################################\n############################################################################################################\nrequire_myfstring = ->\n  ```\n  \"use strict\";\n  // Object.defineProperty(exports, \"__esModule\", { value: true });\n  // exports.injectFormatToString = exports.format = exports.formatByParam = void 0;\n\n  function toNonExponential(num) {\n      var m = parseFloat(num).toExponential().toString().match(/\\d(?:\\.(\\d*))?e([+-]\\d+)/);\n      var fractionDigits = 0;\n      if (m !== null) {\n          if (m[1] === undefined) {\n              m[1] = '';\n          }\n          var tmp = m[1].length - parseInt(m[2]);\n          if (tmp > 0) {\n              fractionDigits = tmp;\n          }\n      }\n      return parseFloat(num).toFixed(fractionDigits);\n  }\n  function divideBySign(num, sign) {\n      var reg = /\\d{1,3}(?=(\\d{3})+$)/g;\n      var tmpArr = num.split('.');\n      var after = '';\n      if (tmpArr.length > 1) {\n          after = '.' + tmpArr[1];\n      }\n      return tmpArr[0].replace(reg, '$&' + sign) + after;\n  }\n  function formatByParam(raw, formatString) {\n      var result = '';\n      var formatStringBackup = '';\n      if ((!/[s]{1}$/.test(formatString) && parseInt(raw) === NaN) || formatString.search(/^:/) === -1 || formatString === ':') {\n          result = raw;\n          return result;\n      }\n      formatStringBackup = formatString;\n      formatString = formatString.split(':')[1];\n      var textAlign = '';\n      var fillChar = '';\n      var tmp = /[\\^<>]{1}/.exec(formatString);\n      if (tmp !== null) {\n          var tmp_str_arr = formatString.split(/[\\^<>]{1}/);\n          fillChar = tmp_str_arr[0];\n          formatString = tmp_str_arr[1];\n          if (fillChar.length != 1) {\n              var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) - 1) + \"^\";\n              throw new SyntaxError('Bad format input:fillChar must one char of string.\\n' + erroInfo);\n          }\n          switch (tmp[0]) {\n              case '^':\n                  textAlign = 'center';\n                  break;\n              case '<':\n                  textAlign = 'left';\n                  break;\n              case '>':\n                  textAlign = 'right';\n                  break;\n              default:\n                  textAlign = '';\n          }\n      }\n      var sign = '';\n      tmp = /^[\\+\\- ]{1}/.exec(formatString);\n      if (tmp !== null) {\n          switch (tmp[0]) {\n              case '+':\n                  sign = '+';\n                  break;\n              case '-':\n                  sign = '';\n                  break;\n              case ' ':\n                  sign = ' ';\n                  break;\n              default:\n                  sign = '';\n          }\n          formatString = formatString.slice(1);\n          if (formatString.search(/[\\+\\- ]{1}/) !== -1) {\n              var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) + 1) + \"^\";\n              throw new SyntaxError('Bad format input:Multiple sign.\\n' + erroInfo);\n          }\n      }\n      var isHash = false;\n      if (/^#{1}/.test(formatString)) {\n          isHash = true;\n          formatString = formatString.slice(1);\n          if (formatString.search('#') !== -1) {\n              var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) + 1) + \"^\";\n              throw new SyntaxError('Bad format input:Multiple hash.\\n' + erroInfo);\n          }\n      }\n      var isFillZero = false;\n      if (/^0{1}/.test(formatString)) {\n          isFillZero = true;\n          formatString = formatString.slice(1);\n          if (formatString.search(/^0+/) !== -1) {\n              var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) + 1) + \"^\";\n              throw new SyntaxError('Bad format input:Multiple before fill zero.\\n' + erroInfo);\n          }\n      }\n      var width = 0;\n      tmp = /^(\\d*)/.exec(formatString);\n      if (tmp !== null) {\n          width = parseInt(tmp[0]);\n      }\n      formatString = formatString.replace(/^(\\d*)/, '');\n      var separation = '';\n      tmp = /^[,_]{1}/.exec(formatString);\n      if (tmp !== null) {\n          switch (tmp[0]) {\n              case ',':\n                  separation = ',';\n                  break;\n              case '_':\n                  separation = '_';\n          }\n          formatString = formatString.slice(1);\n          if (formatString.search(/[,_]{1}/) !== -1) {\n              var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) + 1) + \"^\";\n              throw new SyntaxError('Bad format input:Multiple separation sign.\\n' + erroInfo);\n          }\n      }\n      var decimalWidth = 6;\n      tmp = /(?<=^\\.)(\\d+)/.exec(formatString);\n      if (tmp !== null) {\n          decimalWidth = parseInt(tmp[0]);\n          formatString = formatString.replace(/^\\.+\\d+/, '');\n          if (formatString.search(/^\\.{1}/) !== -1) {\n              var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) + 1) + \"^\";\n              throw new SyntaxError('Bad format input:Multiple decimal point.\\n' + erroInfo);\n          }\n      }\n      var format = 's';\n      if (/^[bdoxfegs%]{1}$/i.exec(formatString) !== null) {\n          format = formatString;\n      }\n      else {\n          var erroInfo = \"Error point at:\\n[\" + formatStringBackup + \"]\\n\" + ' '.repeat(formatStringBackup.search(formatString) + 1) + \"^\";\n          throw new SyntaxError('Bad format input:Formatting flag is not in [[bdoxfgs%]].\\n' + erroInfo);\n      }\n      if (textAlign === '') {\n          if (/[sS]/.test(format)) {\n              textAlign = 'left';\n          }\n          else if (/[bdoxfg%]/i.test(format))\n              (textAlign = 'right');\n      }\n      var offset = 0;\n      var fillset = 0;\n      decimalWidth = decimalWidth > width ? width : decimalWidth;\n      if (/[sS]/.test(format)) {\n          raw = raw.slice(0, decimalWidth);\n      }\n      else if (/[fg%]/i.test(format)) {\n          raw = raw.replace(/[^\\+\\-\\.0-9eEoObBdDxXn]/g, '');\n          if (/e{1}/i.test(raw)) {\n              raw = toNonExponential(raw);\n          }\n          if (format === 'g' || format === 'G') {\n              raw = parseFloat(raw).toPrecision(decimalWidth).toString();\n          }\n          else if (format === 'f' || format === 'F') {\n              raw = parseFloat(raw).toFixed(decimalWidth).toString();\n          }\n          else if (format === '%') {\n              raw = (parseFloat(raw) * 100).toFixed(decimalWidth).toString() + '%';\n          }\n          if (format !== '%') {\n              raw = divideBySign(raw, separation);\n          }\n          if (!/^[-]{1}/.test(raw)) {\n              raw = sign + raw;\n          }\n          if (isFillZero && fillChar === \"\") {\n              raw = raw.replace(/^[\\-\\+ ]?/, '$&' + '0'.repeat(width - raw.length));\n          }\n      }\n      else if (/[eE]/i.test(format)) {\n          raw = parseFloat(raw).toExponential(decimalWidth).toString();\n          raw = sign + raw;\n          if (isFillZero && fillChar === \"\") {\n              raw = raw.replace(/^[\\-\\+ ]?/, '$&' + '0'.repeat(width - raw.length));\n          }\n      }\n      else if (/[bdox]/i.test(format)) {\n          var radix = 10;\n          var symbol = '';\n          switch (format.toLowerCase()) {\n              case 'b':\n                  radix = 2;\n                  symbol = '0b';\n                  break;\n              case 'o':\n                  radix = 8;\n                  symbol = '0o';\n                  break;\n              case 'x':\n                  radix = 16;\n                  symbol = '0x';\n                  break;\n              case 'd':\n                  radix = 10;\n                  break;\n              default:\n                  radix = 10;\n          }\n          decimalWidth = 0;\n          raw = parseInt(raw).toString(radix);\n          if (isHash) {\n              if (/[OXB]{1}/.test(format)) {\n                  symbol = symbol.toUpperCase();\n              }\n              raw = raw.replace(/^[\\-\\+]?/, '$&' + symbol);\n          }\n          if (!/^[-]{1}/.test(raw)) {\n              raw = sign + raw;\n          }\n          if (isFillZero && fillChar === \"\") {\n              raw = raw.replace(/^[\\-\\+]?(?:0[oxb]{1})?/i, '$&' + '0'.repeat(width - raw.length));\n          }\n      }\n      if (width > raw.length) {\n          switch (textAlign) {\n              case 'left':\n                  offset = 0;\n                  fillset = width - raw.length;\n                  break;\n              case 'right':\n                  offset = width - raw.length;\n                  fillset = 0;\n                  break;\n              case 'center':\n                  offset = Math.trunc((width - raw.length) / 2);\n                  fillset = width - raw.length - offset;\n          }\n      }\n      if (fillChar === '') {\n          fillChar = ' ';\n      }\n      result = fillChar.repeat(offset) + raw + fillChar.repeat(fillset);\n      return result;\n  }\n  exports.formatByParam = formatByParam;\n  function format(param) {\n      var paramsIsFormat = false;\n      var formatString = '';\n      var raw = \"\";\n      if (/^:.*[bdoxfgse%]{1}$/i.test(param)) {\n          paramsIsFormat = true;\n      }\n      if (!paramsIsFormat && !/^:.*[bdoxfgse%]{1}$/i.test(this)) {\n          throw new SyntaxError('Bad format input:least one of this string and parameter is a format style string.');\n      }\n      if (paramsIsFormat) {\n          formatString = param;\n          raw = this;\n      }\n      else {\n          formatString = this;\n          raw = param;\n      }\n      return formatByParam(raw, formatString);\n  }\n  // exports.format = format;\n  // function injectFormatToString() {\n  //     String.prototype.format = format;\n  // }\n  // exports.injectFormatToString = injectFormatToString;\n  //# sourceMappingURL=FStringFormat.js.map\n  ```\n  #=========================================================================================================\n  return do =>\n\n    #-------------------------------------------------------------------------------------------------------\n    format = ( fmt, x ) ->\n      x = rpr x unless ( typeof x ) is 'string'\n      return formatByParam x, fmt\n\n    #-------------------------------------------------------------------------------------------------------\n    new_formatter = ( fmt ) -> ( x ) -> format fmt, x\n\n    #-------------------------------------------------------------------------------------------------------\n    return { format, new_formatter, }\n\n############################################################################################################\n############################################################################################################\n############################################################################################################\n\n#-----------------------------------------------------------------------------------------------------------\n{ f, injectFormatToString, } = require 'fstring'\n# debug 'Ω___1', ( require 'fstring' ).formatByParam\ndebug 'Ω___2', f\ndebug 'Ω___3', injectFormatToString\ndebug 'Ω___4', injectFormatToString()\n\n# import { injectFormatToString,f} from 'fstring'\n# injectFormatToString()\n# 格式化字符串 风格一:\n\n# fmt = ':_>+20,.5g'\nfmt = ': > 15,.2f'\nhelp 'Ω___5', fmt.format '1'\nhelp 'Ω___6', fmt.format '12'\nhelp 'Ω___7', fmt.format '123'\nhelp 'Ω___8', fmt.format '1234'\nhelp 'Ω___9', fmt.format '-11456.15454'\nhelp 'Ω__10', fmt.format '53443.32455'\nhelp 'Ω__11', fmt.format '885673.367553'\nfmt = ': > 15s'\nhelp 'Ω__12', fmt.format 'helo'\ninfo 'Ω__13', '11456.15454'.format ':*<+20,.5g'\ninfo 'Ω__14', ':*<+20,.5g'.format '11456.15454'\n\n{ format, new_formatter, } = require_myfstring()\nurge 'Ω__15', format ':*<+20,.5g', '11456.15454'\nurge 'Ω__16', format ':*<+20,.5g', 11456.15454\n# urge 'Ω__17', format ':*=+20,.5g', 11456.15454\n\nf152f = new_formatter ': > 15,.2f'\nhelp 'Ω__18', f152f 1\nhelp 'Ω__19', f152f 12\nhelp 'Ω__20', f152f 123\nhelp 'Ω__21', f152f 1234\nhelp 'Ω__22', f152f -11456.15454\nhelp 'Ω__23', f152f 53443.32455\nhelp 'Ω__24', f152f 885673.367553\nf15s = new_formatter ': > 15s'\nhelp 'Ω__25', f15s 'helo'\n"
  ]
}