{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/demo-dbase-infinite-stable-ordered-vnrs.coffee"
  ],
  "names": [],
  "mappings": "AAoHG;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n###\n\n* naming:\n  * bi(nary)-vectorial numbers (BVNs)\n  * pairs; paired row numbers\n\n* 'infinitely' expandable (within boundaries given by datatype), stably-ordered indexing in database\n  (specifically SQLite via [DBay]())\n* no recursive CTEs are needed, `order by` with one or two fields is enough to reconstruct proper ordering\n  of records before and after processing\n* stably-ordered as they control ordering in a stable fashion\n  * but volatile in the sense that after insertions and deletions VNRs must be re-written ('ironed') before\n    new rows can be inserted at points where directly before insertions had taken place (but can insert\n    around other points in table)\n* using numerical values but format is friendly to serialization; in that case, must beforehand determine\n  capacity; three digits as shown here can represent up to (10^3)-2 = 998 lines from which have to be\n  subtracted the number of revision records whose numbering goes into the same space; using suitable\n  characters for negative vs positive numbers, multiple numerical `nrX` fields can be combined into a single\n  textual field that may serve as a single ordering criterion and a compact display\n  * possible to devise a line-oriented text file format that can represent the original document and all\n    changes in a (barely, for sure) human-readable format\n\n* fields:\n  * **`bvn1`**, **`bvn2`**: BVN components; after reading the file and before any changes, `bvn1` equals the\n    line number and `bvn2` equals zero; after changes and ironing of BVNs, line numbers and `bvn1` values\n    will start to drift apart.\n  * **`oln`**: 'orginal line', ID of line that 'caused' the current record; in a real application, this\n    would have to identify file, line, column\n  * **`s`**: 'stamped'; when `true`, record is obsolete (here written `X`); when `false`, record is active\n    (here written `_`)\n  * **`data`**: arbitrary data, stands in for whatever fields are needed; here special values:\n    * (SOF): always represents Start Of File with `bvn1` set to constant `000`\n    * (EOF): always represents End Of File with `bvn1` set to constant `999`\n\n* records need a stable ID field, fields bvn1, bvn2 will always be volatile\n* negative numbers to be used to insert before a given line\n\n\n* **After reading a file, before further processing**: `data` shows lines of a hypothetical MarkDown file;\n  `bvn1` will correspond to line numbers in the file, but that correspondance is volatile. We use `A` ...\n  `Z` for arbitrary row IDs:\n\n```\nid  bvn1 bvn2 oln s data\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     _ **bar**\nD   +003 +000     _ wat\nE   +999 +000     _ (EOF)\n```\n\nWe want to turn the markup into HTML so have to convert the `**` double-asterisks into `<b>` tags. This\nreplaces the original line (the 'referent') so it gets 'stamped' (here shown by `X`). Just to keep HTML tags\napart from textual content, we split the line into three parts; in cases where that is not needed, we could\nsimply insert a monolithic compiled version.\n\nWe keep a reference to what we replace by setting the `oln` field to `C` (to which a text column number\ncould be added). The new entries keep the `bvn1` field value of their referent value but count the `bvn2`\nfield up to indicate their own local ordering relation. At this point we could still append to the end of\nline `C` or prepend value by setting `bvn2` to negative values; also all other lines can be processed without\nintroducing non-local changes. If we were to change the `<b>` tag into a `<span>` without overwriting,\nthough, there's no space left for that in our scheme.\n\n* **After some changes, before ironing**:\n\n```\nid  bvn1 bvn2 oln s data\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     X **bar**\nF   +002 +001 C   _ <b>\nG   +002 +002 C   _ bar\nH   +002 +003 C   _ </b>\nD   +003 +000     _ wat\nE   +999 +000     _ (EOF)\n```\n\n**After first ironing**: At some point it will be necessary to re-normalize our fields by what we call\n'ironing'; this is accomplished by simply iterating over `select * from T order by bvn1, bvn2`, setting\n`bvn1` to their row numbers and `bvn2` to zero; care is taken to leave the first line as `bvn1: 0` and the\nlast as `bvn1: 999`:\n\n```\nid  bvn1 bvn2 oln s data\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     X **bar**\nF   +003 +000 C   _ <b>\nG   +004 +000 C   _ bar\nH   +005 +000 C   _ </b>\nD   +006 +000     _ wat\nE   +999 +000     _ (EOF)\n```\n\n**After some further changes**: Now we introduce another change in the same location using the same\nprocedures; observe how line `J` points back to line `H` which in turn points back to line `C`; with proper\nindexing (not shown here), we could attribute the origin of this and any other part down the line to\nline&nbsp;2, `**bar**`, specifically columns&nbsp;6,&nbsp;7 of that line so because we're using a proper\ndatabase we gain full traceability with high granularity.\n\n```\nid  bvn1 bvn2 oln s data\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     X **bar**\nF   +003 +000 C   X <b>\nI   +003 +001 F   _ <span>\nG   +004 +000 C   _ bar\nH   +005 +000 C   X </b>\nJ   +005 +001 H   _ </span>\nD   +006 +000     _ wat\nE   +999 +000     _ (EOF)\n```\n\n\n###\n"
  ]
}