{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/demo-dbase-infinite-stable-ordered-vnrs.coffee"
  ],
  "names": [],
  "mappings": "AAsGG;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n###\n\n* naming:\n  * bi(nary)-vectorial numbers (BVNs)\n  * pairs; paired row numbers\n\n* 'infinitely' expandable (within boundaries given by datatype), stably-ordered indexing in database\n  (specifically SQLite via [DBay]())\n* no recursive CTEs are needed, `order by` with one or two fields is enough to reconstruct proper ordering\n  of records before and after processing\n* stably-ordered as they control ordering in a stable fashion\n  * but volatile in the sense that after insertions and deletions VNRs must be re-written ('ironed') before\n    new rows can be inserted at points where directly before insertions had taken place (but can insert\n    around other points in table)\n* using numerical values but format is friendly to serialization; in that case, must beforehand determine\n  capacity; three digits as shown here can represent up to (10^3)-2 = 998 lines from which have to be\n  subtracted the number of revision records whose numbering goes into the same space; using suitable\n  characters for negative vs positive numbers, multiple numerical `nrX` fields can be combined into a single\n  textual field that may serve as a single ordering criterion and a compact display\n\n* fields:\n  * `nr1`, `nr2`: VNR components\n  * `oln`: 'orginal line', ID of line that 'caused' the current record; in a real application, this would\n    have to identify file, line, column\n  * `s`: 'stamped'; when `true`, record is obsolete (here written `X`); when `false`, record is active (here\n    written `_`)\n  * `data`: arbitrary data, stands in for whatever fields are needed; here special values:\n    * (SOF): always represents Start Of File with nr1 set to constant `000`\n    * (EOF): always represents End Of File with nr1 set to constant `999`\n\n* records need a stable ID field, fields nr1, nr2 will always be volatile\n* negative numbers to be used to insert before a given line\n\n\nAfter reading a file, before further processing; `data` shows lines of a hypothetical MarkDown file; `nr1`\nwill correspond to line numbers in the file, but that correspondance is volatile. We use `A` ... `Z` for\narbitrary row IDs:\n\nid  nr1  nr2  oln s data\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     _ **bar**\nD   +003 +000     _ wat\nE   +999 +000     _ (EOF)\n\n| id | nr1  | nr2  | oln | s |   data  |\n|----|------|------|-----|---|---------|\n| A  | +000 | +000 |     | _ | (SOF)   |\n| B  | +001 | +000 |     | _ | foo     |\n| C  | +002 | +000 |     | _ | **bar** |\n| D  | +003 | +000 |     | _ | wat     |\n| E  | +999 | +000 |     | _ | (EOF)   |\n\nWe want to turn the markup into HTML so have to convert the `**` double-asterisks into `<b>` tags. This\nreplaces the original line (the 'referent') so it gets 'stamped' (here shown by `X`). Just to keep HTML tags\napart from textual content, we split the line into three parts; in cases where that is not needed, we could\nsimply insert a monolithic compiled version.\n\nWe keep a reference to what we replace by setting the `oln` field to `C` (to which a text column number\ncould be added). The new entries keep the `nr1` field value of their referent value but count the `nr2`\nfield up to indicate their own local ordering relation. At this point we could still append to the end of\nline `C` or prepend value by setting `nr2` to negative values; also all other lines can be processed without\nintroducing non-local changes. If we were to change the `<b>` tag into a `<span>` without overwriting,\nthough, there's no space left for that in our scheme:\n\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     X **bar**\nF   +002 +001 C   _ <b>\nG   +002 +002 C   _ bar\nH   +002 +003 C   _ </b>\nD   +003 +000     _ wat\nE   +999 +000     _ (EOF)\n\nAt some point it will be necessary to re-normalize our fields by what we call 'ironing'; this is\naccomplished by simply iterating over `select * from T order by nr1, nr2`, setting `nr1` to their row\nnumbers and `nr2` to zero; care is taken to leave the first line as `nr1: 0` and the last as `nr1: 999`:\n\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     X **bar**\nF   +003 +000 C   _ <b>\nG   +004 +000 C   _ bar\nH   +005 +000 C   _ </b>\nD   +006 +000     _ wat\nE   +999 +000     _ (EOF)\n\n\n\nA   +000 +000     _ (SOF)\nB   +001 +000     _ foo\nC   +002 +000     X **bar**\nF   +003 +000 C   X <b>\nI   +003 +001 F   _ <span>\nG   +004 +000 C   _ bar\nH   +005 +000 C   X </b>\nJ   +005 +001 H   _ </span>\nD   +006 +000     _ wat\nE   +999 +000     _ (EOF)\n\n\n###\n"
  ]
}